{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Learning","text":"<p>This place is a recompilation notes on books and courses. When needed, it'll probably contain links to other repositories for specific projects related to courses, but I'll try to keep it all here.</p> <p>This repository is organized to reflect my learning path, including notes from courses, books, projects, and practice problems.</p> <p>Also, as a disclaimer of sorts, I think there are three types of learning: formal learning, non-formal learning and informal learning.</p> <p>This repo is for the second type: non-formal. As such, it doesn't include notes on things I learn day-to-day on the job or other types of personal projects. Also it doesn't include notes on my Civil Engineering clases at UTN FRP nor Software Engineering classes at UNL FICH.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ul> <li>Introduction</li> <li>Folder Structure</li> <li>core_subjects</li> <li>projects</li> <li>practice</li> <li>How to Use This Repository</li> <li>Contributing</li> <li>License</li> </ul>"},{"location":"#introduction","title":"Introduction","text":"<p>This repository serves as a centralized place for all my notes, code, and resources as I progress through various computer science topics. It is inspired by the curriculum from teachyourselfcs.com, and it includes additional materials and practice exercises.</p>"},{"location":"#folder-structure","title":"Folder Structure","text":"<p>The repository is organized into the following main directories:</p>"},{"location":"#core_subjects","title":"core_subjects","text":"<p>Contains notes and materials for each core subject in the curriculum.</p> <pre><code>core_subjects/\n\u251c\u2500\u2500 programming/\n\u2502   \u251c\u2500\u2500 book/\n\u2502   \u2514\u2500\u2500 course/\n\u251c\u2500\u2500 computer_architecture/\n\u2502   \u251c\u2500\u2500 book/\n\u2502   \u2514\u2500\u2500 course/\n\u251c\u2500\u2500 algorithms_and_data_structures/\n\u2502   \u251c\u2500\u2500 book/\n\u2502   \u2514\u2500\u2500 course/\n\u251c\u2500\u2500 mathematics_for_cs/\n\u2502   \u251c\u2500\u2500 book/\n\u2502   \u2514\u2500\u2500 course/\n\u251c\u2500\u2500 operating_systems/\n\u2502   \u251c\u2500\u2500 book/\n\u2502   \u2514\u2500\u2500 course/\n\u251c\u2500\u2500 computer_networking/\n\u2502   \u251c\u2500\u2500 book/\n\u2502   \u2514\u2500\u2500 course/\n\u251c\u2500\u2500 databases/\n\u2502   \u251c\u2500\u2500 book/\n\u2502   \u2514\u2500\u2500 course/\n\u251c\u2500\u2500 languages_and_compilers/\n\u2502   \u251c\u2500\u2500 book/\n\u2502   \u2514\u2500\u2500 course/\n\u2514\u2500\u2500 distributed_systems/\n    \u251c\u2500\u2500 book/\n    \u2514\u2500\u2500 course/\n</code></pre> <ul> <li>Each subject has its own directory with two subdirectories:</li> <li><code>book/</code>: Contains notes, summaries, and insights from textbooks or readings.</li> <li><code>course/</code>: Contains lecture notes, assignments, and related materials from     courses.</li> </ul>"},{"location":"#projects","title":"projects","text":"<p>Contains all project work, including code and documentation.</p> <ul> <li>Projects may include:</li> <li>Implementations of concepts learned.</li> <li>Larger-scale applications or systems.</li> <li>Documentation (<code>docs/</code>), source code (<code>src/</code>), and other relevant files.</li> </ul>"},{"location":"#additional_resources","title":"additional_resources","text":"<p>Contains supplementary materials, practice problems, tools, and useful websites.</p> <pre><code>additional_resources/\n\u251c\u2500\u2500 books/\n\u251c\u2500\u2500 courses/\n\u251c\u2500\u2500 practice/\n\u2502   \u2514\u2500\u2500 leetcode/\n\u2502       \u251c\u2500\u2500 easy/\n\u2502       \u251c\u2500\u2500 medium/\n\u2502       \u251c\u2500\u2500 hard/\n\u2502       \u2514\u2500\u2500 topics/\n\u251c\u2500\u2500 tools/\n\u2514\u2500\u2500 websites/\n</code></pre> <ul> <li>books/: Notes and summaries from additional books outside the core   curriculum.</li> <li>courses/: Materials from extra courses, workshops, or tutorials.</li> <li>practice/: Contains practice problems and solutions.</li> <li>leetcode/: Organized by difficulty and topic, includes problem solutions     and explanations.</li> <li>tools/: Resources and notes on development tools, editors, and   environments.</li> <li>websites/: Links and notes from useful websites, blogs, or online   articles.</li> </ul>"},{"location":"#how-to-use-this-repository","title":"How to Use This Repository","text":"<ul> <li>Navigating Notes:</li> <li>Go to <code>core_subjects/</code> and select the subject you're interested in.</li> <li>Inside each subject, choose <code>book/</code> for textbook notes or <code>course</code> for     course materials.</li> <li>Viewing Projects:</li> <li>Visit the <code>projects/</code> directory to explore practical applications and code.     In some cases, the repo is going to link another repo.</li> <li>Exploring Additional Resources:</li> <li>Check out <code>additional_resources/</code> for supplementary materials.<ul> <li>books/: Find notes from extra books you're reading.</li> <li>courses/: Access materials from additional courses.</li> <li>practice/: Engage with practice problems, especially from LeetCode.</li> <li>Problems are categorized by difficulty and topic for targeted practice.</li> <li>tools/: Learn about various tools and how to use them effectively.</li> <li>websites/: Discover valuable online resources.</li> </ul> </li> </ul>"},{"location":"#license","title":"License","text":"<p>This repository is for personal educational purposes. Please review the LICENSE file for more information.</p>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/","title":"Structure and Interpretation of Computer Programs","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/#resources","title":"Resources","text":"<p>Resources used for this:</p> <p>Video course MIT 6.001 Book \"Structure and Interpretation of Computer Programs\"</p>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/#exercises","title":"Exercises","text":"<p>You can find most exercises on its own folder/subsection. They should work with MIT Scheme, but I changed midway from that implementation to Chez Scheme.</p>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/#notes","title":"Notes","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/","title":"Chapter 1","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#section-116-conditional-expressions-and-predicates","title":"Section 1.1.6 Conditional Expressions and Predicates","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-13","title":"Exercise 1.3","text":"<pre><code>(define (maxsum a b c) \n  (cond \n    ((&gt; a b) (if (&gt; b c) (+ a b) (+ a c)))\n    ((&gt; a c) (if (&gt; b c) (+ a b) (+ a c)))\n    (else (+ b c)))\n    )\n\n(display (maxsum 1 2 3))\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#section-117-example-square-roots-by-newtons-method","title":"Section 1.1.7 Example: Square Roots by Newton's Method","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-18","title":"Exercise 1.8","text":"<pre><code>( define (cubert-iter guess x)\n  ;; (display guess) (newline)\n  (if (cube-good-enough? guess x)\n    guess\n    (cubert-iter (improve-cube-guess guess x) x)))\n\n(define (cube-good-enough? guess x)\n  (&lt; \n    (abs (/ (- (* guess guess guess) x) x))\n    0.1\n  )\n)\n\n(define (improve-cube-guess guess x) \n  (/ \n    (+ (/ x (square guess)) (* 2 guess))\n    3\n  ))\n\n(define (cuberoot x) (cubert-iter 1 x))\n\n(exact-&gt;inexact (cuberoot 27))\n(exact-&gt;inexact (cuberoot 125))\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#section-122-tree-recursion","title":"Section 1.2.2 Tree Recursion;","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-111","title":"Exercise 1.11","text":"<pre><code>(define (f_r n)\n  (cond ((&lt; n 3) n)\n        ((&gt;= n 3)\n         (+ \n           (f_r (- n 1))\n           (* 2 (f_r (- n 2)))\n           (* 3 (f_r (- n 3)))\n           ))))\n\n(define (f_i n)\n  (define (f_i_iter a b c count)\n      (cond \n        ((= count 0) (+ a (* 2 b) (* 3 c))) \n        ((&gt; count 0) (f_i_iter (+ a (* 2 b) (* 3 c)) a b (- count 1)))))\n\n  (cond ((&lt; n 3) n)\n        ((&gt;= n 3)\n          (f_i_iter 2 1 0 (- n 3)))))\n\n\n(f_r 2)\n(f_r 3)\n\n(f_i 2)\n(f_i 3)\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#section-122-tree-recursion_1","title":"Section 1.2.2 Tree Recursion","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-112","title":"Exercise 1.12","text":"<pre><code>(define (pascal col row)\n  (cond ((= row 1) 1)\n        ((= col 1) 1)\n        ((= col row) 1)\n        (else (\n               + \n               (pascal (- col 1) (- row 1))\n               (pascal col (- row 1))\n               ))))\n\n(pascal 3 5)\n\n(pascal 3 5)\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#section-124-exponentiation","title":"Section 1.2.4 Exponentiation","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-116","title":"Exercise 1.16","text":"<pre><code>(define (even a) (= (remainder a 2) 0))\n\n(define (exp b n)\n  (define (iter a b n) \n    (cond \n      ((= n 0) a)\n      ((even n) (iter a (* b b) (/ n 2)))   \n      (else (iter (* a b) b (- n 1)))))\n\n  (iter 1 b n))\n\n\n(exp 3 3)\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-117","title":"Exercise 1.17","text":"<pre><code>(define (double a) (* a 2))\n(define (halve a) (/ a 2))\n(define (even? a) (= 0 (remainder a 2)))\n\n(define (mult a b)\n  (cond\n    ((= b 1) a)\n    ((even? b) (mult (double a) (halve b)))\n    (else (+ a (mult a (- b 1))))))\n\n\n(mult 8 7)\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-118","title":"Exercise 1.18","text":"<pre><code>(define (double a) (* a 2))\n(define (halve a) (/ a 2))\n(define (even? a) (= 0 (remainder a 2)))\n\n(define (mult a b)\n  (define (iter a b i)\n    (cond\n      ((= b 0) i)\n      ((even? b) (iter (double a) (halves b) i))\n      (else (iter a (- b 1) (+ i a)))))\n\n  (iter a b 0))\n\n(mult 8 7)\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#section-125-greatest-common-divisors","title":"Section 1.2.5 Greatest Common Divisors","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-121","title":"Exercise 1.21","text":"<pre><code>(define (smallest-divisor n)\n  (define (divides? a b)\n    (= (remainder b a) 0))\n\n  (define (find-divisor n test-divisor)\n    (cond ((&gt; (square test-divisor) n) n)\n          ((divides? test-divisor n) test-divisor)\n          (else (find-divisor n (+ test-divisor 1)))))\n\n  (find-divisor n 2))\n</code></pre> <p>I guess this made sense back then, but I don't see any runtime difference.</p> <pre><code>(smallest-divisor 199)\n(smallest-divisor 1999)\n(smallest-divisor 19999)\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#section-126-example-testing-for-primality","title":"Section 1.2.6 Example: Testing for Primality","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-122","title":"Exercise 1.22","text":"<pre><code>(define (square x)\n  (* x x))\n\n(define (smallest-divisor n)\n  (define (divides? a b)\n    (= (remainder b a) 0))\n\n  (define (find-divisor n test-divisor)\n    (cond ((&gt; (square test-divisor) n) n)\n          ((divides? test-divisor n) test-divisor)\n          (else (find-divisor n (+ test-divisor 1)))))\n\n  (find-divisor n 2))\n\n(define (prime? n) \n  (if (= n 1) \n    #f\n    (= (smallest-divisor n) n)))\n\n(define (timed-prime-test n)\n  (start-prime-test n (runtime)))\n\n(define (start-prime-test n start-time)\n  (if (prime? n)\n      (report-prime n (- (runtime) start-time))\n      #f))\n\n(define (report-prime n elapsed-time)\n  (display n)\n  (display \" is prime (\")\n  (display elapsed-time)\n  (display \" seconds)\")\n  (newline)\n  #t)\n\n(define (search-for-primes since until amount)\n  (define start-time (runtime))\n\n  (define (iter n until missing)\n    (cond ((= missing 0) \n           (display \"\\nTotal time: \")\n           (display (- (runtime) start-time))\n           (display \" seconds\\n\")\n           'done)\n          ((= (remainder n 2) 0) \n           (iter (+ n 1) until missing))\n          (else \n           (if (timed-prime-test n)\n               (iter (+ n 2) until (- missing 1))\n               (iter (+ n 2) until missing)))))\n\n  (display \"Searching for \")\n  (display amount)\n  (display \" primes between \")\n  (display since)\n  (display \" and \")\n  (display until)\n  (display \":\\n\\n\")\n\n  (iter since until amount))\n\n; Example searches at different ranges\n(search-for-primes 100000000000 10000000000000000 3)\n\n; Uncomment to test other ranges:\n; (search-for-primes 10000 100000 3)\n; (search-for-primes 100000 1000000 3)\n; (search-for-primes 1000000 10000000 3)\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-123","title":"Exercise 1.23","text":"<pre><code>(define (square x)\n  (* x x))\n\n(define (smallest-divisor n)\n  (define (divides? a b)\n    (= (remainder b a) 0))\n\n  (define (next test-divisor) \n    (if (= test-divisor 2) \n        3\n        (+ test-divisor 2)))\n\n  (define (find-divisor n test-divisor)\n    (cond ((&gt; (square test-divisor) n) n)\n          ((divides? test-divisor n) test-divisor)\n          (else (find-divisor n (next test-divisor)))))\n\n  (find-divisor n 2))\n\n(define (prime? n) \n  (= (smallest-divisor n) n))\n\n(define (timed-prime-test n)\n  (start-prime-test n (runtime)))\n\n(define (start-prime-test n start-time)\n  (if (prime? n)\n      (report-prime n (- (runtime) start-time))\n      #f))\n\n(define (report-prime n elapsed-time)\n  (display n)\n  (display \" is prime (\")\n  (display elapsed-time)\n  (display \" seconds)\")\n  (newline)\n  #t)\n\n(define (search-for-primes since until amount)\n  (define start-time (runtime))\n\n  (define (iter n until missing)\n    (cond ((= missing 0) \n           (display \"\\nTotal time: \")\n           (display (- (runtime) start-time))\n           (display \" seconds\\n\")\n           'done)  ; Return a symbol instead of undefined\n          ((= (remainder n 2) 0) \n           (iter (+ n 1) until missing))\n          (else \n           (if (timed-prime-test n)\n               (iter (+ n 2) until (- missing 1))\n               (iter (+ n 2) until missing)))))\n\n  (display \"Searching for \")\n  (display amount)\n  (display \" primes between \")\n  (display since)\n  (display \" and \")\n  (display until)\n  (display \":\\n\\n\")\n\n  (iter since until amount))\n\n; Example usage:\n(search-for-primes 100000000000 10000000000000000 3)\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#section-131-procedures-as-arguments","title":"Section 1.3.1 Procedures as Arguments","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-129","title":"Exercise 1.29","text":"<pre><code>(define (sum term a next b)\n  (if (&gt; a b) \n    0 \n    (+ (term a) \n       (sum term (next a) next b))))\n\n;; Simpson's Rule integration implementation\n(define (integral f a b n)\n  ;; Define h\n  (let ((h (/ (- b a) n)))\n\n  ;; Wrap the term in a lambda to pass the h and a values\n  (define (fs f h a) \n    (lambda (x) \n      (*\n        ;; I guess the diference between this and the other implementation is that\n        ;; I don't create the extra function to calculate the coefficient.\n        (cond ((or (= x 0) (= x n)) 1)\n              ((odd? x) 4)\n              (else 2))\n        (f (+ a (* x h))))))\n\n\n  ;; Increment function\n  (define (next a) (+ a 1))\n\n  ;; Calculate the integral\n  (*\n    (/ h 3)\n    (sum (fs f h a) 0 next n))))\n\n; Test function\n(define (cube x) (* x x x))\n\n; Convert to decimal and compute integral\n(exact-&gt;inexact (integral cube 0 1 100000))\n(integral cube 0 1 100)\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-130","title":"Exercise 1.30","text":"<pre><code>(define (sum term a next b)\n  (define (iter a result)\n    (if (&gt; a b) \n      result\n      (iter (next a) (+ result (term a)))))\n\n  (iter a 0))\n\n;; Simpson's Rule integration implementation\n(define (integral f a b n)\n  ;; Define h\n  (let ((h (/ (- b a) n)))\n\n  ;; Wrap the term in a lambda to pass the h and a values\n  (define (fs f h a) \n    (lambda (x) \n      (*\n        ;; I guess the diference between this and the other implementation is that\n        ;; I don't create the extra function to calculate the coefficient.\n        (cond ((or (= x 0) (= x n)) 1)\n              ((odd? x) 4)\n              (else 2))\n        (f (+ a (* x h))))))\n\n\n  ;; Increment function\n  (define (next a) (+ a 1))\n\n  ;; Calculate the integral\n  (*\n    (/ h 3)\n    (sum (fs f h a) 0 next n))))\n\n; Test function\n(define (cube x) (* x x x))\n\n; Convert to decimal and compute integral\n(exact-&gt;inexact (integral cube 0 1 100000))\n(integral cube 0 1 100)\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-131","title":"Exercise 1.31","text":"<pre><code>(define (product term a next b)\n  (define (iter a result)\n    (if (&gt; a b) \n      result\n      (iter (next a) (* result (term a)))))\n\n  (iter a 1))\n\n(define (factorial n)\n  (define (identity x) x)\n  (define (inc x) (+ x 1))\n  (product identity 1 inc n))\n\n(display (factorial 5))\n</code></pre> <p>For the second part of the exercise, we need to define a term that will</p> <p>calculate the value of the formula given in the exercise. The formula is</p> <p>$\\pi/4=(244668...)/(335577...)$.</p> <pre><code>(define (pi-product n)\n  (define (inc x) (+ x 1))\n  (define (pi-step x)\n    (cond \n      ((= x 0) 1)\n      ((= x 1) 1)\n      ((even? x)\n       ;; (display \"even \")\n       ;; (display x)\n       ;; (display \" / \")\n       ;; (display (+ x 1))\n       ;; (newline)\n       (/ x (+ x 1)))\n      (else\n       ;; (display \"odd \")\n       ;; (display (+ x 1))\n       ;; (display \" / \")\n       ;; (display x)\n       ;; (newline)\n       ;; (newline)\n       (/ (+ x 1) x))))\n\n\n  (product pi-step 0 inc n))\n\n(display (exact-&gt;inexact(pi-product 10000)))\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-132","title":"Exercise 1.32","text":"<pre><code>(define (accumulate combiner null-value term a next b)\n  (define (iter a result)\n    (if (&gt; a b)\n      result\n      (iter (next a) (combiner result (term a)))))\n  (iter a null-value))\n\n(define (accumulate_rec combiner null-value term a next b)\n  (if (&gt; a b)\n    null-value\n    (combiner (term a) (accumulate_rec combiner null-value term (next a) next b))))\n\n\n(define (product term a next b)\n  (define (prod a b) (* a b))\n  (accumulate_rec prod 1 term a next b))\n\n(define (factorial n)\n  (define (identity x) x)\n  (define (inc x) (+ x 1))\n  (product identity 1 inc n))\n\n(display (factorial 5))\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-133","title":"Exercise 1.33","text":"<pre><code>the sum of the squares of the prime numbers in the interval a\n to b\n (assuming that you have a prime? predicate already written)\n\n(load \"1.22.scm\")\n\n(define (accumulate_filter combiner null-value term a next b filter)\n  (define (iter a result)\n    (if (&gt; a b)\n      result\n      (let ((a-value (term a)))\n        (if (filter a)\n          (iter (next a) (combiner result a-value))\n          (iter (next a) result)))))\n  (iter a null-value))\n\n(define (prime_sum a b)\n  (define (inc x) (+ x 1))\n  (define (identity x) x)\n  (accumulate_filter + 0 identity a inc b prime?))\n\n(display (prime_sum 0 100))\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#section-132-constructing-procedures-using-lambda","title":"Section 1.3.2 Constructing Procedures Using Lambda","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-134","title":"Exercise 1.34","text":"<pre><code>(define (f g) (g 2))\n(define (square x) (* x x))\n\n(f square) ; 4\n\n(f (lambda (z) (* z (+ z 1)))) ; 6\n\n(f f)\n</code></pre> <p>The interpreter will evaluate the combination <code>(f f)</code> by substituting <code>f</code></p> <p>with its definition.</p> <p>We'll go: (f f) --&gt; (f 2) --&gt; (2 2) --&gt; error</p>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#section-133-procedures-as-general-methods","title":"Section 1.3.3 Procedures as General Methods","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-136","title":"Exercise 1.36","text":"<pre><code>(define tolerance 0.00001)\n\n(define (fixed-point f first-guess)\n  (define (close-enough? v1 v2)\n    (&lt; (abs (- v1 v2)) tolerance))\n\n  (define (try guess)\n    (newline)\n    (display guess)\n    (let ((next (f guess)))\n      (if (close-enough? guess next)\n        next\n        (try next))))\n\n  (try first-guess))\n\n(define (average x y) (/ (+ x y) 2))\n(define (average-damp f)\n  (lambda (x) (average x (f x))))\n\n(define (func x) (/ (log 1000) (log x)))\n\n(fixed-point func 2.0) ;; 35 steps\n\n(fixed-point (average-damp func) 2.0) ; 9 steps\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-137","title":"Exercise 1.37","text":"<pre><code>(define (cont-fract n d k)\n  (if (= k 0)\n      0\n      (/ (n k)  (+ (d k) (cont-fract n d (- k 1))))))\n\n\n(define (n k) 1.0)\n</code></pre> <p>The desired value is: 0.6180</p> <p>It can be achieved by calling with k = 11</p> <pre><code>(cont-fract n n 11) ; \n(cont-fract n n 11)\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-138","title":"Exercise 1.38","text":"<pre><code>(define (cont-fract n d k)\n  (define (cont-fract-inter n d k i)\n    (if (= i k)\n        0\n        (/ (n i) (+ (d i) (cont-fract-inter n d k (+ i 1))))))\n  (cont-fract-inter n d k 1)) ; start counting from 1\n\n\n(define (n k) 1.0)\n(define (d k)\n  (if (= (remainder k 3) 2)\n      (* 2 (/ (+ k 1) 3))\n      1.0))\n</code></pre> <p>The desired value is $\\e - 2$ which is approximately 0.71828</p> <pre><code>(cont-fract n d 1000)\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-139","title":"Exercise 1.39","text":"<pre><code>(define (cont-fract combinator null-value n d k)\n  (define (cont-fract-inter n d k i)\n    (if (= i k)\n        0\n        (/ (n i) (combinator (d i) (cont-fract-inter n d k (+ i 1))))))\n  (cont-fract-inter n d k null-value))\n\n;; Define the continued fraction for tan(x)\n(define (tan-cf x k)\n  (define (n k) (square x))      ; Numerator is always x^2\n  (define (d k) (+ (* 2 k) 1))   ; Denominator follows 2k + 1 (i.e., 1, 3, 5, ...)\n  (/ x\n     (- 1\n        (cont-fract - 1 n d k))))\n\n\n;; tan(1) = 1.5574077\n\n(display (exact-&gt;inexact (tan-cf 1 100)))\n(newline)\n(display \"done\")\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#section-134-procedures-as-general-methods","title":"Section 1.3.4: Procedures as General Methods","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-140","title":"Exercise 1.40","text":"<pre><code>(define (cubic a b c) (lambda (x) (+ (* x x x) (* a x x) (* b x) c)))\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-141","title":"Exercise 1.41","text":"<pre><code>(define (double f)\n  (lambda (x) (f (f x))))\n\n(define (inc x) (+ x 1))\n\n(((double (double double)) inc) 5) ;; 21\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-142","title":"Exercise 1.42","text":"<pre><code>(define (compose f g)\n  (lambda (x) (f (g x))))\n\n(define (square x) (* x x))\n(define (inc x) (+ x 1))\n\n((compose square inc) 6)\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-143","title":"Exercise 1.43","text":"<pre><code>(define (compose f g)\n  (lambda (x) (f (g x))))\n\n(define (square x) (* x x))\n(define (inc x) (+ x 1))\n\n((compose square inc) 6)\n\n(define (repeated f n)\n  (define (iter res m)\n    (if (= m 0)\n      res\n      (iter (f res) (- m 1))))\n\n  (lambda (x) (iter x n)))\n\n((repeated square 2) 5)\n(define (compose f g)\n  (lambda (x) (f (g x))))\n\n(define (square x) (* x x))\n(define (inc x) (+ x 1))\n\n((compose square inc) 6)\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-1-exercises/#exercise-144","title":"Exercise 1.44","text":"<pre><code>(define dx 0.000001)\n\n(define soothe\n  (lambda (f)\n    (lambda (x)\n      (/ (+ (f (- x dx))\n            (f x)\n            (f (+ x dx)))\n         3))))\n\n;; I won't repeat the repeated procedure here, but it seems very straightforward.\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/","title":"Chapter 2","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#section-211","title":"Section 2.1.1","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-21","title":"Exercise 2.1","text":"<pre><code>(load \"../utils.scm\") ;; gcd implementation\n\n(define (make-rat n d)\n  (let ((abn (abs n)) (abd (abs d)))\n    (let ((a (gcd abn abd)))\n      (if (&gt; 0 (* n d))\n        (cons (* -1 (/ abn a)) (/ abd a))\n        (cons (/ abn a) (/ abd a))))))\n\n(define (numer rn) (car rn))\n(define (denom rn) (cdr rn))\n\n(define t (make-rat 6 -18))\n(numer t)\n(denom t)\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#section-212","title":"Section 2.1.2","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-22","title":"Exercise 2.2","text":"<pre><code>(load \"../utils.scm\") ; average implementation\n\n;; Point definition\n(define (make-point x y) (cons x y))\n(define (x-point p) (car p))\n(define (y-point p) (cdr p))\n\n;; Segment definition\n(define (make-segment a b) (cons a b))\n(define (segment-start s) (car s))\n(define (segment-end s)  (cdr s))\n\n(define (print-point p)\n  (newline)\n  (display \"(\")\n  (display (x-point p))\n  (display \",\")\n  (display (y-point p))\n  (display \")\"))\n\n(define (midpoint l)\n  (make-point \n    (average \n      (x-point (segment-start l))\n      (x-point (segment-end l)))\n    (average \n      (y-point (segment-start l))\n      (y-point (segment-end l)))))\n\n\n(define seg (make-segment (make-point 0 0) (make-point 10 10)))\n\n(print-point (midpoint seg))\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#section-213-what-is-meant-by-data","title":"Section 2.1.3: What is meant by data","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-204","title":"Exercise 2.04","text":"<pre><code>(define (cons x y)\n  (lambda (m) (m x y)))\n\n(define (cons s)\n  (s (lambda (x y) x)))\n\n(define (car z)\n  (z (lambda (x y) y)))\n\n\n(display (car (cons 1 2)))\n(newline)\n(display (cdr (cons 1 2)))\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-205","title":"Exercise 2.05","text":"<pre><code>(define zero (lambda (f) (lambda (x) x)))\n\n(define add-1 (lambda (n) (lambda (f) (lambda (x) (f ((n f) x))))))\n\n(define one (lambda (f) (lambda (x) (f x))))\n\n(define two (lambda (f) (lambda (x) (f (f x)))))\n\n(define (sum a b)\n  (lambda (f)\n    (lambda (x)\n      ((a f) ((b f) x)))))\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#section-214-extended-exercise-interval-arithmetic","title":"Section 2.1.4: Extended Exercise: Interval Arithmetic","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-207","title":"Exercise 2.07","text":"<pre><code>(define (make-interval a b) (cons a b))\n\n(define add-interval\n  (lambda (x y)\n    (make-interval (+ (lower-bound x) (lower-bound y))\n                   (+ (upper-bound x) (upper-bound y)))))\n\n(define mul-interval\n  (lambda (x y)\n    (let ((p1 (* (lower-bound x) (lower-bound y)))\n          (p2 (* (lower-bound x) (upper-bound y)))\n          (p3 (* (upper-bound x) (lower-bound y)))\n          (p4 (* (upper-bound x) (upper-bound y))))\n\n      (make-interval (min p1 p2 p3 p4) (max p1 p2 p3 p4)))))\n\n(define (div-interval x y)\n  (mul-interval \n    x\n    (make-interval \n      (/ 1.0 (upper-bound y))\n      (/ 1.0 (lower-bound y)))))\n</code></pre> <p>My code..</p> <pre><code>(define upper-bound\n  (lambda (x)\n    (cdr x)))\n\n(define lower-bound\n  (lambda (x)\n    (car x)))\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-208","title":"Exercise 2.08","text":"<pre><code>(load \"./2.07.scm\")\n\n(define sub-interval\n  (lambda (x y)\n    (add-interval \n      x \n      (make-interval\n        (* -1 (lower-bound y))\n        (* -1 (upper-bound y))))))\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-209","title":"Exercise 2.09","text":"<pre><code>(load \"2.08.scm\")\n\n(define (with interval)\n  (/ (- (upper-bound interval) (lower-bound interval))\n     2.0))\n\n(define a (make-interval 5 10))\n(define b (make-interval 20 30))\n\n\n(display (with a)) ;; 2.5\n(display (with b)) ;; 5\n\n(display (with (add-interval a b))) ;; 7.5\n(display (with (sub-interval b a))) ;; 2.5\n\n(display (with (mul-interval a b))) ;; 100\n(display (with (div-interval b a))) ;; 2\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#section-221-representing-sequences","title":"Section 2.2.1: Representing sequences","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-217","title":"Exercise 2.17","text":"<pre><code>(define (last-pair p)\n  (if (null? (cdr p))\n    (car p)\n    (last-pair (cdr p))))\n\n(last-pair (list 23 72 149 34))\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-218","title":"Exercise 2.18","text":"<pre><code>(define (reverse p)\n  (cond \n    ((null? p) nil)\n    ((null? (cdr p)) (list (car p)))\n    (else (append (reverse (cdr p)) \n                  (list (car p))))))\n\n(display (reverse (list 23 72 149 34)))\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-219","title":"Exercise 2.19","text":"<pre><code>(define (cc amount coins)\n  (cond ((= amount 0) 1)\n        ((or (&lt; amount 0) (= (length coins) 0)) 0)\n        (else (+ (cc amount\n                     (cdr coins))\n                 (cc (- amount\n                       (car coins))\n                     coins)))))\n\n(define us-coins (list 1 5 10 25 50))\n(define uk-coins (list 1 2 5 10 20 50 100))\n\n(cc 100 us-coins)  ;;=&gt; 292\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-220","title":"Exercise 2.20","text":"<pre><code>(define (same-parity . l)\n  (define (iter-sp res l rem)\n    (if (null? l)\n      res \n      (if \n        (= \n          (remainder (car l) 2)\n          rem)\n        (iter-sp \n          (append res (list (car l)))\n          (cdr l)\n          rem)\n        (iter-sp \n          res \n          (cdr l) \n          rem))))\n\n  (iter-sp (list (car l)) (cdr l) (remainder (car l) 2)))\n\n(same-parity 1 2 3 4 5 6 7)\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-221","title":"Exercise 2.21","text":"<pre><code>(load \"../utils.scm\") ; square definition\n\n(define (square-list items)\n  (map square items))\n\n(square-list (list 1 2 3 4 5))\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-223","title":"Exercise 2.23","text":"<pre><code>(define (for-each proc items)\n  (cond ((null? items) #t)\n        (else (proc (car items))\n              (for-each proc (cdr items)))))\n\n(for-each (lambda(x) (newline) (display x))\n          (list 57 321 88))\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#section-222-hierarchical-structures","title":"Section 2.2.2: Hierarchical Structures","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-225","title":"Exercise 2.25","text":"<pre><code>(define a (list 1 3 (list 5 7) 9))\n(define b (list (list 7)))\n(define c (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7)))))))\n\n\n(car (cdaddr a))\n(caar b)\n(cadadr (cadadr (cadadr c))) \n\n(define x (list 1 2 3))\n(define y (list 4 5 6))\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-227","title":"Exercise 2.27","text":"<pre><code>(define (deep-reverse p)\n  (cond \n    ((null? p) '())\n    ((not (pair? p)) p)\n    (else \n      (append \n        (deep-reverse (cdr p))\n        (list (deep-reverse (car p)))))))\n\n(display (deep-reverse (list 23 72 149 34)))\n\n(define x (list (list 1 2) (list 3 4)))\n(display x)\n(display (deep-reverse x))\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-228","title":"Exercise 2.28","text":"<pre><code>(define (fringe lst)\n  (display \"Fringe \")\n  (display lst)\n  (newline)\n  (cond \n    ((not (pair? lst)) (list lst))\n    ((null? (cdr lst)) (fringe (car lst)))\n    (else\n      (append\n        (fringe (car lst))\n        (fringe (cdr lst))))))\n\n(define x (list (list 1 2) (list 3 4)))\n(newline)\n(display (fringe x))\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-229","title":"Exercise 2.29","text":"<pre><code>(define (make-mobile left right)\n  (list left right))\n\n(define (make-branch length structure)\n  (list length structure))\n\n(define (is-mobile? obj)\n  (if (and\n        (pair? obj)\n        (pair? (left-branch obj))\n        (pair? (right-branch obj)))\n    #t \n    #f))\n</code></pre> <p>Part a</p> <pre><code>(define (left-branch mobile)\n  (car mobile))\n\n(define (right-branch mobile)\n  (cadr mobile))\n\n(define (branch-length branch)\n  (car branch))\n\n(define (branch-structure branch)\n  (cadr branch))\n</code></pre> <p>Part b</p> <pre><code>(define (total-weight structure)\n  (if (is-mobile? structure)\n    (+  \n      (total-weight (branch-structure (left-branch structure)))\n      (total-weight (branch-structure (right-branch structure))))\n    structure))))\n</code></pre> <p>Part c</p> <pre><code>(define (is-balanced? structure)\n  (if (is-mobile? structure)\n    (if (and\n        (is-balanced? (branch-structure (left-branch structure)))\n        (is-balanced? (branch-structure (right-branch structure)))\n        (= \n          (* \n            (branch-length (left-branch structure))\n            (total-weight (branch-structure (left-branch structure))))\n          (* \n            (branch-length (right-branch structure))\n            (total-weight (branch-structure (right-branch structure))))))\n      #t\n      #f)\n    #t))\n</code></pre> <p>Example usage. This should output a weight of 26, and not be balanced.</p> <pre><code>(define m (make-mobile\n  (make-branch 10 (make-mobile (make-branch 5 10) (make-branch 25 2)))\n  (make-branch 10 (make-mobile\n                    (make-branch 10 (make-mobile (make-branch 5 10) (make-branch 25 2))) \n                    (make-branch 25 2)))))\n\n(display \"Example 1\")\n(newline)\n(display (is-balanced? m))\n(newline)\n(display (total-weight m))\n(newline)\n</code></pre> <p>This one should output a weight of 40, and be balanced.</p> <pre><code>(define balanced (make-mobile\n  (make-branch 4 (make-mobile\n                   (make-branch 6 (make-mobile (make-branch 6 4) (make-branch 4 6))) \n                   (make-branch 6 (make-mobile (make-branch 6 4) (make-branch 4 6)))))\n  (make-branch 4 (make-mobile\n                   (make-branch 6 (make-mobile (make-branch 6 4) (make-branch 4 6))) \n                   (make-branch 6 (make-mobile (make-branch 6 4) (make-branch 4 6)))))))\n\n(display \"Example 2\")\n(newline)\n(display (is-balanced? balanced))\n(newline)\n(display (total-weight balanced))\n(newline)\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-230","title":"Exercise 2.30","text":"<pre><code>(load \"../utils.scm\") ;; square, map definitions\n\n(define (square-tree tree)\n  (map (lambda (sub-tree)\n         (if (pair? sub-tree)\n           (square-tree sub-tree)\n           (square sub-tree)))\n       tree))\n\n(square-tree (list 1\n                   (list 2 (list 3 4) 5)\n                   (list 6 7)))\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-231","title":"Exercise 2.31","text":"<pre><code>(load \"../utils.scm\") ;; square, map definitions\n\n(define (tree-map tree proc)\n  (map (lambda (sub-tree)\n         (if (pair? sub-tree)\n           (tree-map sub-tree proc)\n           (proc sub-tree)))\n       tree))\n\n(define (square-tree tree) (tree-map tree square))\n\n(square-tree (list 1\n                   (list 2 (list 3 4) 5)\n                   (list 6 7)))\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#section-223-sequences-as-conventional-interfaces","title":"Section 2.2.3: Sequences as Conventional Interfaces","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-233","title":"Exercise 2.33","text":"<pre><code>(load \"../utils.scm\") ;; acumulate definition\n(define (ac_map p sequence)\n  (accumulate \n    (lambda (x y) (cons (p x) y)) \n    '()\n    sequence))\n\n(define (ac_append seq1 seq2)\n  (accumulate cons seq2 seq1))\n\n(define (ac_length sequence)\n  (accumulate (lambda (x y) (+ x 1)) 0 sequence))\n\n\n(ac_map square (list 1 2 3))\n(ac_append (list 1 2 3) (list 4 5 7))\n(ac_length (list 1 2 3))\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-234","title":"Exercise 2.34","text":"<pre><code>(load \"../utils.scm\")\n\n(define (horner-eval x coefficient-sequence)\n  (accumulate \n    (lambda (this-coeff higher-terms)\n      (+ \n        this-coeff \n        (* higher-terms x)))\n    0\n    coefficient-sequence))\n\n\n(horner-eval 2 (list 1 3 0 5 0 1)) ;; 79\n\n(let ((x 2))\n  (+ 1 (* 3 x) (* 5 (expt x 3)) (expt x 5))) ;; 79\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-236","title":"Exercise 2.36","text":"<pre><code>(load \"../utils.scm\") ;; accumulate definition\n</code></pre> <p>Ok. So first we'll see the first solution I had.It's way too verbose but</p> <p>it works perfectly.</p> <pre><code>(define (select-n n seq)\n  (if (= n 0)\n    (car seq)\n    (select-n (- n 1) (cdr seq))))\n\n(define (enumerate-n n seq)\n  (if (null? seq)\n    '()\n    (cons (select-n n (car seq)) (enumerate-n n (cdr seq)))))\n\n(define (pop n seq)\n  (cond \n    ((= n 0) seq)\n    ((null? seq) '())\n    (else (pop (- n 1) (cdr seq)))))\n\n(define (pop-n seqs)\n  (if (null? seqs) \n    '()\n    (cons \n      (pop 1 (car seqs))\n      (pop-n (cdr seqs)))))\n\n\n(define (accumulate-n op init seqs)\n  (if (null? (car seqs))\n    '() \n    (cons (accumulate op init (enumerate-n 0 seqs))\n          (accumulate-n op init (pop-n seqs)))))\n</code></pre> <p>Later, I came across this solution... It does the exact same thing, but</p> <p>without creating a complex pair of functions to express the idea.</p> <pre><code>(define (accumulate-n op init seqs)\n  (if (null? (car seqs))\n    '() \n    (cons (accumulate op init (map car seqs))\n          (accumulate-n op init (map cdr seqs)))))\n\n(accumulate-n + 0 (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-240","title":"Exercise 2.40","text":"<pre><code>(load \"../utils.scm\") ; flatmap definition\n\n(define (unique-pairs n)\n  (flatmap \n    (lambda (i)\n      (map \n        (lambda (j) (list i j))\n        (enumerate-interval 1 (- i 1))))\n    (enumerate-interval 2 n)))\n\n(unique-pairs 5)\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/Exercises/chapter-2-exercises/#exercise-241","title":"Exercise 2.41","text":"<pre><code>(load \"../utils.scm\")\n\n(define (find-triple-s n s)\n  (filter \n    (lambda (x) (= s (accumulate + 0 x)))\n    (flatmap\n      (lambda (x)\n        (flatmap \n          (lambda (y) \n            (map \n              (lambda (z) (list x y z)) \n              (enumerate-interval 1 (- y 1))))  ; z goes from 1 to y-1\n          (enumerate-interval 2 (- x 1))))      ; y goes from 2 to x-1\n      (enumerate-interval 3 n))))               ; x goes from 3 to n\n\n(find-triple-s 10 10)\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/notes/chapter-1/","title":"Chapter 1","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/notes/chapter-1/#section-11-the-elements-of-programming","title":"Section 1.1: The elements of programming","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/notes/chapter-1/#subsection-111","title":"Subsection 1.1.1","text":"<ul> <li>Every powerful language has these three mechanisms:</li> <li>Primitive expressions, which represent the simplest entities the     language is concerned with.</li> <li>Means of combinations, by which compound elements are built from simpler     ones.</li> <li>Means of abstraction , by which compound elements can be named and     manipulated as units.</li> </ul> <p>In Scheme we can define a variable as:</p>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/notes/chapter-1/#subsection-114","title":"Subsection 1.1.4","text":"<pre><code>(define a 1)\n</code></pre> <p>Or a function like this:</p> <pre><code>(define (square x) (* x x))\n</code></pre> <p>It's important to note how the functions are called:</p> <pre><code>(square 2) ;; 4\n</code></pre>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/notes/chapter-1/#subsection-115","title":"Subsection 1.1.5","text":"<p>The way we can think about how the interpreter executes ours commands can be simplified with the substitution model . This means:</p> <p>To apply a compound procedure to arguments, evaluate the body of the procedure with each formal parameter replaced by the corresponding argument.</p> <p>Also, it's interesting do quote this:</p> <p>[The] alternative \"fully expand and then reduce\" evaluation method is known as normal-order evaluation.</p> <p>This is contrary to what Lisp uses, which is applicative-order evaluation. This allows to reduce redundant calculations.</p>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/notes/chapter-1/#subsection-118","title":"Subsection 1.1.8","text":"<p>Using a decomposition strategy, we can take apart any problem in more atomic subproblems. For these, we then can create procedures that solved them, and use these as 'black boxes' that we use in other places, but don't care about the internal implementation.</p> <p>One of the things we do care about in a procedure are it's parameters, which specify the expected input for the procedure:</p> <p>A formal parameter of a procedure has a very special role in the procedure definition, in that it doesn't matter what name the formal parameter has. Such a name is called a bound variable, and we say that the procedure definition binds its formal parameters. The set of expression for which a binding defines a name is called the scope of that name.</p>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/notes/chapter-1/#section-12-procedures-and-the-processes-they-generate","title":"Section 1.2: Procedures and the processes they generate","text":""},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/notes/chapter-1/#subsection-121","title":"Subsection 1.2.1:","text":"<p>So far, we've seen recursion. But in Lisp, not all recursion is born the same. We can make the distinction in a procedure that's recursive, but the process itself is not.</p> <p>We can see two types of processes in this space: recursive processes and iterative processes. Both created by recursive procedures.</p> <p>Consider this implementation of a factorial using a recursive process:</p> <pre><code>(define (factorial n)\n  (if (= n 0)\n      1\n      (* n (factorial (- n 1)))))\n</code></pre> <p>On the other hand, we can also have a similar process that's going to be iterative. This is done by passing along partial results to the next iteration.</p> <pre><code>(define (factorial n)\n  (define (iter product counter)\n    (if (&gt; counter n)\n        product\n        (iter (* counter product)\n              (+ counter 1))))\n  (iter 1 1))\n</code></pre> <p>Normally, recursive processes are easier to come up with, as they follow a more \"mathematical\" definition, as seen with the factorial definition. In most cases, a iterative process is going to have a smaller space complexity.</p>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/notes/chapter-1/#subsection-122","title":"Subsection 1.2.2","text":"<p>I'll write down the solution for the example of counting change, as it's a neat way to see how we can create a iterative process while also traversing a tree of options.</p> <p>We can ask: how many different way can we make change of $1.00, given half-dollars, quarters, dimes, nickels and pennies?</p> <p>To solve this, we can see that the full range of possibilities can be thought of as the sum of all possibilities where N is in the solution, (for example, a half-dollars), and all the possibilities that don't have N.</p> <pre><code>(define (cc amount kinds-of-coins)\n  (cond ((= amount 0) 1)\n        ((or (&lt; amount 0) (= kinds-of-coins 0)) 0)\n        (else (+ (cc amount\n                     (- kinds-of-coins 1))\n                 (cc (- amount\n                       (first-denomination kinds-of-coins))\n                     kinds-of-coins)))))\n\n(define (first-denomination kinds-of-coins)\n  (cond\n    ((= kinds-of-coins 1 ) 1)\n    ((= kinds-of-coins 2) 5)\n    ((= kinds-of-coins 3) 10)\n    ((= kinds-of-coins 4) 25)\n    ((= kinds-of-coins 5) 50)))\n\n(define (count-change amount)\n  (cc amount  5))\n\n(count-change 100) =&gt; 292\n</code></pre> <p>In this case, the important observation is that creating a recursive process to solve this is more or less simple once we arrive at the algorithm, but creating a iterative process for this is not very obvious.</p>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/notes/chapter-1/#section-13-formulating-abstractions-with-higher-order-procedures","title":"Section 1.3: Formulating Abstractions with Higher-Order Procedures","text":"<p>In Lisp-like languages: procedures themselves can be treated as data. This allows us to create higher-order procedures \u2014 procedures that manipulate other procedures as if they were simple data values.</p> <p>This is important, as for example, with cubing, we could get away by always using the computation <code>(* b b b)</code> to express the cube of <code>b</code>, but even tho we could compute it, our language would not be able to express the concept of cubing.</p>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/notes/chapter-1/#section-131","title":"Section 1.3.1","text":"<p>A key idea is that we can pass procedures as arguments to other procedures. For example, consider the problem of summing the values of a function at integer points over a given range. Instead of writing separate summation procedures for different functions (e.g., summing squares, summing cubes, etc.), we can write a single, general sum procedure that takes as an argument the function to be applied:</p> <pre><code>(define (sum term a next b)\n  (if (&gt; a b)\n      0\n      (+ (term a) (sum term (next a) next b))))\n</code></pre> <p>This allows as to create the sum of many other things, like integers, pi-approximation, etc.</p> <p>Also, it allows us to use it as a black box. If we build things on the <code>sum</code> function, which is implemented as a recursive process, we wouldn't have to change anything on top of it if we later change it for a iterative process.</p>"},{"location":"teachyourselfcs/programming/Structure%20and%20Interpretation%20of%20Computer%20Programs/notes/chapter-1/#section-132","title":"Section 1.3.2","text":"<ul> <li>Anonymous Procedures: lambda allows the creation of procedures without   naming them, which is essential for defining short-lived functions used in   specific contexts without polluting the namespace.</li> <li>Higher-Order Functions: By enabling functions to be passed as arguments   and returned as results, lambda facilitates the creation of more abstract and   reusable code structures.</li> </ul> <pre><code>(define (make-adder n)\n  (lambda (x) (+ x n)))\n\n(define add-five (make-adder 5))\n(add-five 10) ; Returns 15\n\n(define add-ten (make-adder 10))\n(add-ten 10) ; Returns 20\n</code></pre>"}]}